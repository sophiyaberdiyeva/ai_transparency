# -*- coding: utf-8 -*-
"""png_to_txt_tesseract_ocr_s.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qj_XsQZ4yAkUcN5xcx5P-nqHiEquSCTV

Code written in co-authorship with Claude Sonnet 4 and ChatGPT4
"""

#!pip install tesseract pytesseract layoutparser fitz tools
#!pip install 'git+https://github.com/facebookresearch/detectron2.git'

import os
import re
from pathlib import Path

import pytesseract
from PIL import Image
import cv2
import layoutparser as lp
import fitz  # PyMuPDF
from detectron2.model_zoo import get_config_file

#os.chdir('/content/drive/MyDrive/Max Planck student job/LLM_lit_review')
# YOU DIDN'T SEE THAT

# Specify the path to the Tesseract executable if needed (Windows only)
pytesseract.pytesseract.tesseract_cmd = r'/usr/local/bin/pytesseract'

# Load the layoutparser model globally to avoid reinitialization
MODEL = lp.models.Detectron2LayoutModel(
    config_path=get_config_file('COCO-Detection/fast_rcnn_R_50_FPN_1x.yaml'),
    model_path="/content/drive/MyDrive/Max Planck student job/LLM_lit_review/Fast_R_CNN_R50_FPN_model_final_e5f7ce.pkl",  # use local file
    extra_config=["MODEL.ROI_HEADS.SCORE_THRESH_TEST", 0.5],
    label_map={0: "Text", 1: "Title", 2: "List", 3: "Table", 4: "Figure"},
    device='cpu'
)


def natural_sort_key(text):
    """Function for natural sorting of files with numbers"""
    return [int(c) if c.isdigit() else c.lower() for c in re.split('([0-9]+)', text)]


def extract_text_from_png(png_path):
    """Extracts text from a PNG file using layoutparser to handle multi-column layout"""
    try:
        image = cv2.imread(str(png_path))
        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        layout = MODEL.detect(image_rgb)

        # Keep only text and title blocks, and sort them top-to-bottom, left-to-right
        text_blocks = lp.Layout([b for b in layout if b.type in ['Text', 'Title']])
        text_blocks = lp.Layout(sorted(text_blocks, key=lambda b: (b.block.y_1, b.block.x_1)))

        extracted_text = ""
        for block in text_blocks:
            segment = block.pad(left=5, right=5, top=5, bottom=5)  # padding to improve OCR
            segment_image = segment.crop_image(image_rgb)
            segment_pil = Image.fromarray(segment_image)
            text = pytesseract.image_to_string(segment_pil, lang='eng', config='--psm 6')
            extracted_text += text.strip() + "\n\n"

        return extracted_text.strip()

    except Exception as e:
        print(f"Error with layoutparser on {png_path}: {e}")
        return ""


def extract_text_from_pdf(pdf_path):
    """Extracts text from a PDF file (fallback method)"""
    try:
        doc = fitz.open(pdf_path)
        text = ""
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            text += page.get_text()
        doc.close()
        return text.strip()
    except Exception as e:
        print(f"Error processing PDF {pdf_path}: {e}")
        return ""


def detect_headers(text):
    """Simple function to detect headers by patterns and convert to markdown"""
    lines = text.split('\n')
    processed_lines = []
    for line in lines:
        line = line.strip()
        if not line:
            processed_lines.append('')
            continue
        if (len(line) < 100 and
            (line.isupper() or
             (line[0].isupper() and len(line.split()) <= 10) or
             re.match(r'^[IVX]+\.\s+', line) or
             re.match(r'^\d+\.\s+', line) or
             re.match(r'^[A-Z][a-z]+\s+\d+', line))):
            processed_lines.append(f"## {line}")
        else:
            processed_lines.append(line)
    return '\n'.join(processed_lines)


def get_pdf_base_name(png_filename):
    """Extract the base name of the PDF from PNG filename."""
    base_name = re.sub(r'_\d+-\d+\.png$', '', png_filename)
    return base_name


def process_article_folder(folder_path):
    """Processes a folder with PNG files representing a single article"""
    folder_path = Path(folder_path)
    png_files = [file for file in folder_path.iterdir() if file.suffix.lower() == '.png']
    if not png_files:
        print(f"No PNG files found in folder {folder_path.name}")
        return None

    png_files.sort(key=lambda x: natural_sort_key(x.name))
    base_name = get_pdf_base_name(png_files[0].stem)
    full_text = ""

    for i, png_file in enumerate(png_files, 1):
        print(f"  Processing page {i}/{len(png_files)}: {png_file.name}")
        page_text = extract_text_from_png(png_file)
        if page_text:
            if i > 1:
                full_text += f"\n\n---\n**Page {i}**\n\n"
            else:
                full_text += f"**Page {i}**\n\n"
            formatted_text = detect_headers(page_text)
            full_text += formatted_text

    return base_name, full_text


def main():
    root_folder = 'data/test_conversion/PDF'
    root_path = Path(root_folder)
    article_folders = [f for f in root_path.iterdir() if f.is_dir()]
    print(f"Found {len(article_folders)} folders with articles")

    for folder in article_folders:
        try:
            result = process_article_folder(folder)
            if result:
                base_name, article_text = result
                output_file = folder / f"{base_name}_ocr.txt"
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(article_text)
                print(f"✓ Article saved: {output_file}")
            else:
                print(f"✗ Failed to process folder: {folder.name}")
        except Exception as e:
            print(f"✗ Error processing {folder.name}: {e}")

    print("\nProcessing completed!")


if __name__ == "__main__":
    main()

os.getcwd()

!rm -rf /root/.torch/iopath_cache/